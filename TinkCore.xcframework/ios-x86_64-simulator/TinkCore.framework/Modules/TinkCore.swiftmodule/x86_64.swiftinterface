// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name TinkCore
import Dispatch
import Foundation
import Security
import Swift
import UIKit
public struct AccessToken : Swift.Hashable, Swift.RawRepresentable {
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(_ value: Swift.String)
  public typealias RawValue = Swift.String
}
public struct Account {
  public enum Kind {
    case checking
    case savings
    case investment
    case mortgage
    case creditCard
    case loan
    case pension
    case other
    case external
    case unknown
    public static func == (a: TinkCore.Account.Kind, b: TinkCore.Account.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public typealias ID = TinkCore.Identifier<TinkCore.Account>
  public let accountNumber: Swift.String
  public let credentialsID: TinkCore.Credentials.ID
  public let id: TinkCore.Account.ID
  public let name: Swift.String
  public let kind: TinkCore.Account.Kind
  public let transferSourceIdentifiers: [Foundation.URL]?
  public let holderName: Swift.String?
  public let isClosed: Swift.Bool?
  public let currencyDenominatedBalance: TinkCore.CurrencyDenominatedAmount?
  public let refreshed: Foundation.Date?
  public let financialInstitutionID: TinkCore.Provider.FinancialInstitution.ID?
  public init(id: TinkCore.Account.ID, credentialsID: TinkCore.Credentials.ID, name: Swift.String, accountNumber: Swift.String, kind: TinkCore.Account.Kind, transferSourceIdentifiers: [Foundation.URL]?, holderName: Swift.String?, isClosed: Swift.Bool?, currencyDenominatedBalance: TinkCore.CurrencyDenominatedAmount?, refreshed: Foundation.Date?, financialInstitutionID: TinkCore.Provider.FinancialInstitution.ID?)
}
extension Account : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.Account, b: TinkCore.Account) -> Swift.Bool
}
public struct AccountNumberKind : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public init(_ value: Swift.String)
  public let value: Swift.String
  public static let iban: TinkCore.AccountNumberKind
  public static let se: TinkCore.AccountNumberKind
  public static let seBankGiro: TinkCore.AccountNumberKind
  public static let sePlusGiro: TinkCore.AccountNumberKind
  public static let sortCode: TinkCore.AccountNumberKind
  public typealias StringLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.AccountNumberKind, b: TinkCore.AccountNumberKind) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public protocol AccountService {
  func accounts(completion: @escaping (Swift.Result<[TinkCore.Account], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct ActionableInsight {
  public typealias ID = TinkCore.Identifier<TinkCore.ActionableInsight>
  public struct InsightAction {
    public let label: Swift.String?
    public let data: TinkCore.InsightActionData?
    public init(label: Swift.String?, data: TinkCore.InsightActionData?)
  }
  public enum State {
    case active([TinkCore.ActionableInsight.InsightAction])
    case archived(Foundation.Date)
  }
  public enum Kind {
    case accountBalanceLow(TinkCore.ActionableInsight.AccountBalanceLowData)
    case budgetOverspent(TinkCore.ActionableInsight.BudgetSummary)
    case budgetCloseNegative(TinkCore.ActionableInsight.BudgetSummary)
    case budgetClosePositive(TinkCore.ActionableInsight.BudgetSummary)
    case budgetSuccess(TinkCore.ActionableInsight.BudgetSummary)
    case budgetSummaryAchieved(TinkCore.ActionableInsight.BudgetPeriodSummary)
    case budgetSummaryOverspent(TinkCore.ActionableInsight.BudgetPeriodSummary)
    case largeExpense(TinkCore.ActionableInsight.LargeExpense)
    case singleUncategorizedTransaction(TinkCore.Transaction.ID)
    case doubleCharge([TinkCore.Transaction.ID])
    case weeklyUncategorizedTransactions(TinkCore.ActionableInsight.WeeklyTranscations)
    case weeklySummaryExpensesByCategory(TinkCore.ActionableInsight.WeeklyExpensesByCategory)
    case weeklySummaryExpensesByDay(TinkCore.ActionableInsight.WeeklyExpensesByDay)
    case monthlySummaryExpensesByCategory(TinkCore.ActionableInsight.MonthlyExpensesByCategory)
    case weeklySummaryExpenseTransactions(TinkCore.ActionableInsight.WeeklyTransactionsSummary)
    case monthlySummaryExpenseTransactions(TinkCore.ActionableInsight.MonthlyTransactionsSummary)
    case newIncomeTransaction(TinkCore.ActionableInsight.NewIncomeTransaction)
    case suggestSetUpSavingsAccount(TinkCore.ActionableInsight.SuggestSetUpSavingsAccount)
    case creditCardLimitClose(TinkCore.ActionableInsight.CreditCardLimit)
    case creditCardLimitReached(TinkCore.ActionableInsight.CreditCardLimit)
    case leftToSpendPositiveMidMonth(TinkCore.ActionableInsight.LeftToSpendMidMonth)
    case leftToSpendNegativeMidMonth(TinkCore.ActionableInsight.LeftToSpendMidMonth)
    case leftToSpendNegativeSummary(TinkCore.ActionableInsight.LeftToSpendNegativeSummary)
    case budgetSuggestCreateTopCategory(TinkCore.ActionableInsight.BudgetSuggestCreateTopCategory)
    case budgetSuggestCreateFirst
    case leftToSpendPositiveBeginningMonth(TinkCore.ActionableInsight.LeftToSpendBeginningMonth)
    case leftToSpendNegativeBeginningMonth(TinkCore.ActionableInsight.LeftToSpendBeginningMonth)
    case leftToSpendNegative(TinkCore.ActionableInsight.LeftToSpendNegative)
    case spendingByCategoryIncreased(TinkCore.ActionableInsight.SpendingByCategoryIncreased)
    case leftToSpendPositiveSummarySavingsAccount(TinkCore.ActionableInsight.LeftToSpendPositiveSummarySavingsAccount)
    case leftToSpendPositiveFinalWeek(TinkCore.ActionableInsight.LeftToSpendPositiveFinalWeek)
    case aggregationRefreshPSD2Credentials(TinkCore.ActionableInsight.AggregationRefreshPSD2Credentials)
    case unknown
  }
  public let id: TinkCore.ActionableInsight.ID
  public let kind: TinkCore.ActionableInsight.Kind
  public let state: TinkCore.ActionableInsight.State
  public let title: Swift.String
  public let description: Swift.String
  public let created: Foundation.Date
  public init(id: TinkCore.ActionableInsight.ID, kind: TinkCore.ActionableInsight.Kind, state: TinkCore.ActionableInsight.State, title: Swift.String, description: Swift.String, created: Foundation.Date)
}
extension ActionableInsight {
  public struct AccountBalanceLowData {
    public let accountID: TinkCore.Account.ID
    public let balance: TinkCore.CurrencyDenominatedAmount
    public init(accountID: TinkCore.Account.ID, balance: TinkCore.CurrencyDenominatedAmount)
  }
  public struct BudgetSummary {
    public let budgetID: TinkCore.Budget.ID
    public let budgetPeriod: TinkCore.ActionableInsight.BudgetPeriod
    public init(budgetID: TinkCore.Budget.ID, budgetPeriod: TinkCore.ActionableInsight.BudgetPeriod)
    @available(*, deprecated, renamed: "budgetID")
    public var budgetId: TinkCore.Budget.ID {
      get
    }
    @available(*, deprecated, renamed: "init(budgetID:budgtePeriod:)")
    public init(budgetId: TinkCore.Budget.ID, budgetPeriod: TinkCore.ActionableInsight.BudgetPeriod)
  }
  public struct BudgetPeriod {
    public let dateInterval: Foundation.DateInterval
    public let spentAmount: TinkCore.CurrencyDenominatedAmount
    public let budgetAmount: TinkCore.CurrencyDenominatedAmount
    public init(dateInterval: Foundation.DateInterval, spentAmount: TinkCore.CurrencyDenominatedAmount, budgetAmount: TinkCore.CurrencyDenominatedAmount)
  }
  public enum BudgetPeriodUnit {
    case year
    case month
    case week
    case unspecified
    public static func == (a: TinkCore.ActionableInsight.BudgetPeriodUnit, b: TinkCore.ActionableInsight.BudgetPeriodUnit) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public struct BudgetPeriodSummary {
    public let achievedBudgets: [TinkCore.ActionableInsight.BudgetSummary]
    public let overspentBudgets: [TinkCore.ActionableInsight.BudgetSummary]
    public let periodUnit: TinkCore.ActionableInsight.BudgetPeriodUnit
    public init(achievedBudgets: [TinkCore.ActionableInsight.BudgetSummary], overspentBudgets: [TinkCore.ActionableInsight.BudgetSummary], periodUnit: TinkCore.ActionableInsight.BudgetPeriodUnit)
    @available(*, deprecated, message: "Use `periodUnit` instead.")
    public var period: Swift.String {
      get
    }
    @available(*, deprecated, message: "Use `init(achievedBudgets:overspentBudgets:period:)` instead")
    public init(achievedBudgets: [TinkCore.ActionableInsight.BudgetSummary], overspentBudgets: [TinkCore.ActionableInsight.BudgetSummary], period: Swift.String)
  }
  public struct LargeExpense {
    public let transactionID: TinkCore.Transaction.ID
    public let amount: TinkCore.CurrencyDenominatedAmount
    public init(transactionID: TinkCore.Transaction.ID, amount: TinkCore.CurrencyDenominatedAmount)
  }
  public struct WeeklyTranscations {
    public let transactionIDs: [TinkCore.Transaction.ID]
    public let week: TinkCore.ActionableInsight.Week
    public init(transactionIDs: [TinkCore.Transaction.ID], week: TinkCore.ActionableInsight.Week)
  }
  public struct CategorySpending {
    public let categoryCode: TinkCore.Category.Code
    public let spentAmount: TinkCore.CurrencyDenominatedAmount
    public init(categoryCode: TinkCore.Category.Code, spentAmount: TinkCore.CurrencyDenominatedAmount)
  }
  public struct TransactionSummary {
    public struct TransactionsOverview {
      public let totalCount: Swift.Int
      public let mostCommonDescription: Swift.String
      public let mostCommonCount: Swift.Int
      public init(totalCount: Swift.Int, mostCommonDescription: Swift.String, mostCommonCount: Swift.Int)
    }
    public struct LargestExpense {
      public let id: TinkCore.Transaction.ID
      public let date: Foundation.Date
      public let amount: TinkCore.CurrencyDenominatedAmount
      public let description: Swift.String
      public init(id: TinkCore.Transaction.ID, date: Foundation.Date, amount: TinkCore.CurrencyDenominatedAmount, description: Swift.String)
    }
    public let totalExpenses: TinkCore.CurrencyDenominatedAmount
    public let commonTransactionsOverview: TinkCore.ActionableInsight.TransactionSummary.TransactionsOverview
    public let largestExpense: TinkCore.ActionableInsight.TransactionSummary.LargestExpense
    public init(totalExpenses: TinkCore.CurrencyDenominatedAmount, commonTransactionsOverview: TinkCore.ActionableInsight.TransactionSummary.TransactionsOverview, largestExpense: TinkCore.ActionableInsight.TransactionSummary.LargestExpense)
  }
  public struct WeeklyExpensesByCategory {
    public let week: TinkCore.ActionableInsight.Week
    public let expensesByCategory: [TinkCore.ActionableInsight.CategorySpending]
    public init(week: TinkCore.ActionableInsight.Week, expensesByCategory: [TinkCore.ActionableInsight.CategorySpending])
  }
  public struct WeeklyExpensesByDay {
    public struct ExpenseStatisticsByDay {
      public let day: TinkCore.ActionableInsight.Day
      public let expenseStatistics: TinkCore.ActionableInsight.WeeklyExpensesByDay.ExpenseStatistics
      public init(day: TinkCore.ActionableInsight.Day, expenseStatistics: TinkCore.ActionableInsight.WeeklyExpensesByDay.ExpenseStatistics)
      @available(*, deprecated, message: "Use init(day:expenseStatistics:) instead.")
      public init(date: Swift.String, expenseStatistics: TinkCore.ActionableInsight.WeeklyExpensesByDay.ExpenseStatistics)
      @available(*, deprecated, message: "Use day property instead.")
      public var date: Swift.String {
        get
      }
    }
    public struct ExpenseStatistics {
      public let totalAmount: TinkCore.CurrencyDenominatedAmount
      public let averageAmount: TinkCore.CurrencyDenominatedAmount
      public init(totalAmount: TinkCore.CurrencyDenominatedAmount, averageAmount: TinkCore.CurrencyDenominatedAmount)
    }
    public let week: TinkCore.ActionableInsight.Week
    public let expenseStatisticsByDay: [TinkCore.ActionableInsight.WeeklyExpensesByDay.ExpenseStatisticsByDay]
    public init(week: TinkCore.ActionableInsight.Week, expenseStatisticsByDay: [TinkCore.ActionableInsight.WeeklyExpensesByDay.ExpenseStatisticsByDay])
  }
  public struct WeeklyTransactionsSummary {
    public let week: TinkCore.ActionableInsight.Week
    public let summary: TinkCore.ActionableInsight.TransactionSummary
    public init(week: TinkCore.ActionableInsight.Week, summary: TinkCore.ActionableInsight.TransactionSummary)
  }
  public struct MonthlyExpensesByCategory {
    public let month: TinkCore.ActionableInsight.Month
    public let expensesByCategory: [TinkCore.ActionableInsight.CategorySpending]
    public init(month: TinkCore.ActionableInsight.Month, expensesByCategory: [TinkCore.ActionableInsight.CategorySpending])
  }
  public struct NewIncomeTransaction {
    public let transactionID: TinkCore.Transaction.ID
    public let accountID: TinkCore.Account.ID
    public init(transactionID: TinkCore.Transaction.ID, accountID: TinkCore.Account.ID)
  }
  public struct MonthlyTransactionsSummary {
    public let month: TinkCore.ActionableInsight.Month
    public let summary: TinkCore.ActionableInsight.TransactionSummary
    public init(month: TinkCore.ActionableInsight.Month, summary: TinkCore.ActionableInsight.TransactionSummary)
  }
  public struct Month {
    public let year: Swift.Int
    public let month: Swift.Int
    public init(year: Swift.Int, month: Swift.Int)
  }
  public struct Week {
    public let year: Swift.Int
    public let week: Swift.Int
    public init(year: Swift.Int, week: Swift.Int)
  }
  public struct Day {
    public let year: Swift.Int
    public let month: Swift.Int
    public let day: Swift.Int
    public init(year: Swift.Int, month: Swift.Int, day: Swift.Int)
  }
  public struct AccountInfo {
    public let id: TinkCore.Account.ID
    public let name: Swift.String
    public init(id: TinkCore.Account.ID, name: Swift.String)
  }
  public struct SuggestSetUpSavingsAccount {
    @available(*, deprecated, message: "Use ActionableInsight.AccountInfo instead.")
    public typealias AccountInfo = TinkCore.ActionableInsight.AccountInfo
    public let balance: TinkCore.CurrencyDenominatedAmount
    public let savingsAccount: TinkCore.ActionableInsight.AccountInfo
    public let currentAccount: TinkCore.ActionableInsight.AccountInfo
    public init(balance: TinkCore.CurrencyDenominatedAmount, savingsAccount: TinkCore.ActionableInsight.AccountInfo, currentAccount: TinkCore.ActionableInsight.AccountInfo)
  }
  public struct CreditCardLimit {
    public let account: TinkCore.ActionableInsight.AccountInfo
    public let availableCredit: TinkCore.CurrencyDenominatedAmount?
    public init(account: TinkCore.ActionableInsight.AccountInfo, availableCredit: TinkCore.CurrencyDenominatedAmount?)
  }
  public struct LeftToSpendStatistics {
    public let createdAt: Foundation.Date
    public let currentLeftToSpend: TinkCore.CurrencyDenominatedAmount
    public let averageLeftToSpend: TinkCore.CurrencyDenominatedAmount
    public init(createdAt: Foundation.Date, currentLeftToSpend: TinkCore.CurrencyDenominatedAmount, averageLeftToSpend: TinkCore.CurrencyDenominatedAmount)
  }
  public struct LeftToSpendMidMonth {
    public let month: TinkCore.ActionableInsight.Month
    public let amountDifference: TinkCore.CurrencyDenominatedAmount
    public let leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics
    public init(month: TinkCore.ActionableInsight.Month, amountDifference: TinkCore.CurrencyDenominatedAmount, leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics)
  }
  public struct LeftToSpendNegativeSummary {
    public let month: TinkCore.ActionableInsight.Month
    public let leftToSpend: TinkCore.CurrencyDenominatedAmount
    public init(month: TinkCore.ActionableInsight.Month, leftToSpend: TinkCore.CurrencyDenominatedAmount)
  }
  public struct BudgetSuggestCreateTopCategory {
    public let categorySpending: TinkCore.ActionableInsight.CategorySpending
    public let suggestedBudgetAmount: TinkCore.CurrencyDenominatedAmount
    public init(categorySpending: TinkCore.ActionableInsight.CategorySpending, suggestedBudgetAmount: TinkCore.CurrencyDenominatedAmount)
  }
  public struct LeftToSpendBeginningMonth {
    public let month: TinkCore.ActionableInsight.Month
    public let amountDifference: TinkCore.CurrencyDenominatedAmount
    public let totalExpense: TinkCore.CurrencyDenominatedAmount
    public let leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics
    public init(month: TinkCore.ActionableInsight.Month, amountDifference: TinkCore.CurrencyDenominatedAmount, totalExpense: TinkCore.CurrencyDenominatedAmount, leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics)
  }
  public struct LeftToSpendNegative {
    public let month: TinkCore.ActionableInsight.Month
    public let createdAt: Foundation.Date
    public let leftToSpend: TinkCore.CurrencyDenominatedAmount
    public init(month: TinkCore.ActionableInsight.Month, createdAt: Foundation.Date, leftToSpend: TinkCore.CurrencyDenominatedAmount)
  }
  public struct CategoryInfo {
    public let id: TinkCore.Category.ID
    public let code: TinkCore.Category.Code
    public let name: Swift.String
    public init(id: TinkCore.Category.ID, code: TinkCore.Category.Code, name: Swift.String)
  }
  public struct SpendingByCategoryIncreased {
    public let category: TinkCore.ActionableInsight.CategoryInfo
    public let lastMonth: TinkCore.ActionableInsight.Month
    public let lastMonthSpending: TinkCore.CurrencyDenominatedAmount
    public let twoMonthsAgoSpending: TinkCore.CurrencyDenominatedAmount
    public let percentage: Swift.Double
    public init(category: TinkCore.ActionableInsight.CategoryInfo, lastMonth: TinkCore.ActionableInsight.Month, lastMonthSpending: TinkCore.CurrencyDenominatedAmount, twoMonthsAgoSpending: TinkCore.CurrencyDenominatedAmount, percentage: Swift.Double)
  }
  public struct LeftToSpendPositiveSummarySavingsAccount {
    public let month: TinkCore.ActionableInsight.Month
    public let leftAmount: TinkCore.CurrencyDenominatedAmount
    public init(month: TinkCore.ActionableInsight.Month, leftAmount: TinkCore.CurrencyDenominatedAmount)
  }
  public struct LeftToSpendPositiveFinalWeek {
    public let month: TinkCore.ActionableInsight.Month
    public let amountDifference: TinkCore.CurrencyDenominatedAmount
    public let leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics
    public let leftToSpendPerDay: TinkCore.CurrencyDenominatedAmount
    public init(month: TinkCore.ActionableInsight.Month, amountDifference: TinkCore.CurrencyDenominatedAmount, leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics, leftToSpendPerDay: TinkCore.CurrencyDenominatedAmount)
  }
  public struct ProviderInfo {
    public let id: TinkCore.Provider.ID
    public let displayName: Swift.String
    public init(id: TinkCore.Provider.ID, displayName: Swift.String)
  }
  public struct AggregationRefreshPSD2Credentials {
    public let credentialsID: TinkCore.Credentials.ID
    public let provider: TinkCore.ActionableInsight.ProviderInfo
    public let sessionExpiryDate: Foundation.Date
    public init(credentialsID: TinkCore.Credentials.ID, provider: TinkCore.ActionableInsight.ProviderInfo, sessionExpiryDate: Foundation.Date)
  }
}
public enum InsightActionData {
  public struct ViewBudget {
    public let budgetID: TinkCore.Budget.ID
    public let budgetPeriodStartTime: Foundation.Date
    public init(budgetID: TinkCore.Budget.ID, budgetPeriodStartTime: Foundation.Date)
  }
  public struct CreateTransfer {
    public let sourceAccount: Foundation.URL?
    public let destinationAccount: Foundation.URL?
    public let amount: TinkCore.CurrencyDenominatedAmount?
    public init(sourceAccount: Foundation.URL?, destinationAccount: Foundation.URL?, amount: TinkCore.CurrencyDenominatedAmount?)
  }
  public struct ViewTransaction {
    public let transactionID: TinkCore.Transaction.ID
    public init(transactionID: TinkCore.Transaction.ID)
  }
  public struct CategorizeSingleExpense {
    public let transactionID: TinkCore.Transaction.ID
    public init(transactionID: TinkCore.Transaction.ID)
  }
  public struct ViewTransactions {
    public let transactionIDs: [TinkCore.Transaction.ID]
    public init(transactionIDs: [TinkCore.Transaction.ID])
  }
  public struct CategorizeTransactions {
    public let transactionIDs: [TinkCore.Transaction.ID]
    public init(transactionIDs: [TinkCore.Transaction.ID])
  }
  public struct ViewTransactionsByCategory {
    public let transactionIdsByCategory: [TinkCore.Category.Code : [TinkCore.Transaction.ID]]
    public init(transactionIdsByCategory: [TinkCore.Category.Code : [TinkCore.Transaction.ID]])
  }
  public struct BudgetSuggestion {
    public let filters: [TinkCore.Budget.Filter]
    public let amount: TinkCore.CurrencyDenominatedAmount?
    public let periodicity: TinkCore.Budget.Periodicity?
    public init(filters: [TinkCore.Budget.Filter], amount: TinkCore.CurrencyDenominatedAmount?, periodicity: TinkCore.Budget.Periodicity?)
  }
  case unknown
  case acknowledge
  case dismiss
  case viewBudget(TinkCore.InsightActionData.ViewBudget)
  case createTransfer(TinkCore.InsightActionData.CreateTransfer)
  case viewTransaction(TinkCore.Transaction.ID)
  case categorizeExpense(TinkCore.Transaction.ID)
  case viewTransactions([TinkCore.Transaction.ID])
  case categorizeTransactions([TinkCore.Transaction.ID])
  case viewTransactionsByCategory([TinkCore.Category.Code : [TinkCore.Transaction.ID]])
  case viewAccount(TinkCore.Account.ID)
  case viewLeftToSpend(TinkCore.ActionableInsight.Month)
  case createBudget(TinkCore.InsightActionData.BudgetSuggestion)
  case refreshCredentials(TinkCore.Credentials.ID)
}
public protocol ActionableInsightService {
  func insights(completion: @escaping (Swift.Result<[TinkCore.ActionableInsight], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func archivedInsights(completion: @escaping (Swift.Result<[TinkCore.ActionableInsight], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func selectAction(insightAction: Swift.String, insightID: TinkCore.ActionableInsight.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func archive(id: TinkCore.ActionableInsight.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public protocol AuthenticationService {
  func clientDescription(clientID: Swift.String, scopes: [TinkCore.Scope], redirectURI: Foundation.URL, completion: @escaping (Swift.Result<TinkCore.ClientDescription, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func authorize(clientID: Swift.String, redirectURI: Foundation.URL, scopes: [TinkCore.Scope], completion: @escaping (Swift.Result<TinkCore.AuthorizationCode, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct AuthorizationCode : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(_ value: Swift.String)
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct Beneficiary : Swift.Equatable {
  @available(*, deprecated, renamed: "accountNumberKind")
  public var accountNumberType: Swift.String {
    get
  }
  public let accountNumberKind: TinkCore.AccountNumberKind
  public let accountNumber: Swift.String
  public let name: Swift.String
  public let ownerAccountID: TinkCore.Account.ID
  public init(accountNumberKind: TinkCore.AccountNumberKind, accountNumber: Swift.String, name: Swift.String, ownerAccountID: TinkCore.Account.ID)
  public static func == (a: TinkCore.Beneficiary, b: TinkCore.Beneficiary) -> Swift.Bool
}
public protocol BeneficiaryService {
  func beneficiaries(completion: @escaping (Swift.Result<[TinkCore.Beneficiary], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func create(accountNumberKind: TinkCore.AccountNumberKind, accountNumber: Swift.String, name: Swift.String, ownerAccountID: TinkCore.Account.ID, credentialsID: TinkCore.Credentials.ID, appURI: Foundation.URL, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct Budget {
  public typealias ID = TinkCore.Identifier<TinkCore.Budget>
  public enum Periodicity : Swift.Equatable {
    case oneOff(TinkCore.Budget.OneOffPeriodicity)
    case recurring(TinkCore.Budget.RecurringPeriodicity)
    public static func == (a: TinkCore.Budget.Periodicity, b: TinkCore.Budget.Periodicity) -> Swift.Bool
  }
  public struct RecurringPeriodicity : Swift.Equatable {
    public enum PeriodUnit {
      case week
      case month
      case year
      public static func == (a: TinkCore.Budget.RecurringPeriodicity.PeriodUnit, b: TinkCore.Budget.RecurringPeriodicity.PeriodUnit) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public let periodUnit: TinkCore.Budget.RecurringPeriodicity.PeriodUnit
    public init(periodUnit: TinkCore.Budget.RecurringPeriodicity.PeriodUnit)
    public static func == (a: TinkCore.Budget.RecurringPeriodicity, b: TinkCore.Budget.RecurringPeriodicity) -> Swift.Bool
  }
  public struct OneOffPeriodicity : Swift.Equatable {
    public let start: Foundation.Date
    public let end: Foundation.Date
    public init(start: Foundation.Date, end: Foundation.Date)
    public static func == (a: TinkCore.Budget.OneOffPeriodicity, b: TinkCore.Budget.OneOffPeriodicity) -> Swift.Bool
  }
  public enum Filter {
    case account(TinkCore.Account.ID)
    case category(TinkCore.Category.Code)
    case tag(Swift.String)
    case search(Swift.String)
  }
  public let id: TinkCore.Budget.ID
  public let name: Swift.String
  public let amount: TinkCore.CurrencyDenominatedAmount?
  public let filter: [TinkCore.Budget.Filter]
  public let periodicity: TinkCore.Budget.Periodicity?
  public init(id: TinkCore.Budget.ID, name: Swift.String, amount: TinkCore.CurrencyDenominatedAmount?, filter: [TinkCore.Budget.Filter], periodicity: TinkCore.Budget.Periodicity?)
}
extension Budget {
  public struct Transaction {
    public let id: TinkCore.Transaction.ID
    public let amount: TinkCore.CurrencyDenominatedAmount
    public let dispensableAmount: TinkCore.CurrencyDenominatedAmount?
    public let date: Foundation.Date?
    public let description: Swift.String?
    public let categoryCode: TinkCore.Category.Code?
    public let accountID: TinkCore.Account.ID?
    public init(id: TinkCore.Transaction.ID, amount: TinkCore.CurrencyDenominatedAmount, dispensableAmount: TinkCore.CurrencyDenominatedAmount?, date: Foundation.Date?, description: Swift.String?, categoryCode: TinkCore.Category.Code?, accountID: TinkCore.Account.ID?)
  }
}
public struct BudgetDetails {
  public let budgetSpecification: TinkCore.Budget
  public let budgetPeriods: [TinkCore.Budget.Period]
  public let dateInterval: Foundation.DateInterval
  public let totalSpentAmount: TinkCore.CurrencyDenominatedAmount?
  public let averageSpentAmount: TinkCore.CurrencyDenominatedAmount?
  public init(budgetSpecification: TinkCore.Budget, budgetPeriods: [TinkCore.Budget.Period], dateInterval: Foundation.DateInterval, totalSpentAmount: TinkCore.CurrencyDenominatedAmount?, averageSpentAmount: TinkCore.CurrencyDenominatedAmount?)
}
extension Budget {
  public struct Period : Swift.Equatable {
    public let dateInterval: Foundation.DateInterval
    public let spentAmount: TinkCore.CurrencyDenominatedAmount?
    public init(dateInterval: Foundation.DateInterval, spentAmount: TinkCore.CurrencyDenominatedAmount?)
    public static func == (a: TinkCore.Budget.Period, b: TinkCore.Budget.Period) -> Swift.Bool
  }
}
public protocol BudgetService {
  func budgets(includeArchived: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.Budget], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func create(name: Swift.String, amount: TinkCore.CurrencyDenominatedAmount, filter: [TinkCore.Budget.Filter], periodicity: TinkCore.Budget.Periodicity, completion: @escaping (Swift.Result<TinkCore.Budget, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func update(id: TinkCore.Budget.ID, name: Swift.String, amount: TinkCore.CurrencyDenominatedAmount, filter: [TinkCore.Budget.Filter], periodicity: TinkCore.Budget.Periodicity, completion: @escaping (Swift.Result<TinkCore.Budget, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func transactionsForBudget(id: TinkCore.Budget.ID, dateInterval: Foundation.DateInterval, completion: @escaping (Swift.Result<[TinkCore.Budget.Transaction], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func budgetSummaries(includeArchived: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.BudgetSummary], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func budgetDetails(id: TinkCore.Budget.ID, dateInterval: Foundation.DateInterval, completion: @escaping (Swift.Result<TinkCore.BudgetDetails, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func archive(id: TinkCore.Budget.ID, completion: @escaping (Swift.Result<TinkCore.Budget, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct BudgetSummary {
  public let budget: TinkCore.Budget
  public let budgetPeriod: TinkCore.Budget.Period
  public init(budget: TinkCore.Budget, budgetPeriod: TinkCore.Budget.Period)
}
public protocol CalendarService {
  func period(period: Swift.String, completion: @escaping (Swift.Result<[TinkCore.Period], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public protocol Cancellable {
  func cancel()
}
public struct Category : Swift.Equatable {
  public typealias ID = TinkCore.Identifier<TinkCore.Category>
  public let id: TinkCore.Category.ID
  public let code: TinkCore.Category.Code
  public let name: Swift.String
  public let sortOrder: Swift.Int
  public let parent: TinkCore.Category.ID?
  public init(id: TinkCore.Category.ID, code: TinkCore.Category.Code, name: Swift.String, sortOrder: Swift.Int, parent: TinkCore.Category.ID?)
  public static func == (a: TinkCore.Category, b: TinkCore.Category) -> Swift.Bool
}
extension Category {
  public struct Code : Swift.Hashable, Swift.ExpressibleByStringLiteral {
    public let value: Swift.String
    public init(_ value: Swift.String)
    public init(stringLiteral value: Swift.String)
    public typealias StringLiteralType = Swift.String
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TinkCore.Category.Code, b: TinkCore.Category.Code) -> Swift.Bool
  }
}
extension Category.Code {
  public var isExpense: Swift.Bool {
    get
  }
  public var isIncome: Swift.Bool {
    get
  }
  public var isTransfer: Swift.Bool {
    get
  }
  public var type: TinkCore.Category.Kind {
    get
  }
  public var isUncategorized: Swift.Bool {
    get
  }
  public var isReimbursement: Swift.Bool {
    get
  }
  public var isSavings: Swift.Bool {
    get
  }
  public var isExcluded: Swift.Bool {
    get
  }
  public var isOther: Swift.Bool {
    get
  }
  public var isMiscOther: Swift.Bool {
    get
  }
  public var isExpensesOther: Swift.Bool {
    get
  }
  public var isRootCategory: Swift.Bool {
    get
  }
  public var isSubcategory: Swift.Bool {
    get
  }
  public func isChild(of parent: TinkCore.Category.Code) -> Swift.Bool
}
extension Category {
  public enum Kind : Swift.String, Swift.Hashable {
    case expenses
    case income
    case transfers
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
extension Category.Kind {
  public init(code: TinkCore.Category.Code)
  public var categoryCode: TinkCore.Category.Code {
    get
  }
}
public protocol CategoryService {
  func categories(completion: @escaping (Swift.Result<[TinkCore.Category], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct ClientDescription {
  public let name: Swift.String
  public let scopes: [TinkCore.ScopeDescription]
  public let isVerified: Swift.Bool
  public let isAggregator: Swift.Bool
}
extension Tink {
  public struct Configuration {
    public var clientID: Swift.String
    public var redirectURI: Foundation.URL
    public var environment: TinkCore.Environment
    public var restCertificateURL: Foundation.URL?
    public init(clientID: Swift.String, redirectURI: Foundation.URL, environment: TinkCore.Environment = .production, certificateURL: Foundation.URL? = nil) throws
    @available(*, deprecated, message: "Use init(clientID:redirectURI:environment:certificateURL:) instead")
    public init(clientID: Swift.String, redirectURI: Foundation.URL, environment: TinkCore.Environment = .production, grpcCertificateURL: Foundation.URL? = nil, restCertificateURL: Foundation.URL? = nil) throws
  }
}
public struct Credentials : Swift.Identifiable {
  public typealias ID = TinkCore.Identifier<TinkCore.Credentials>
  public let id: TinkCore.Credentials.ID
  public let providerID: TinkCore.Provider.ID
  public enum Kind {
    case unknown
    case password
    case mobileBankID
    case keyfob
    case fraud
    case thirdPartyAuthentication
    public var sortOrder: Swift.Int {
      get
    }
    public static func == (a: TinkCore.Credentials.Kind, b: TinkCore.Credentials.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let kind: TinkCore.Credentials.Kind
  public enum Status {
    case unknown
    case created
    case authenticating
    case updating
    case updated
    case temporaryError
    case authenticationError
    case permanentError
    case awaitingMobileBankIDAuthentication
    case awaitingSupplementalInformation
    case disabled
    case awaitingThirdPartyAppAuthentication
    case sessionExpired
    public static func == (a: TinkCore.Credentials.Status, b: TinkCore.Credentials.Status) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let status: TinkCore.Credentials.Status
  public let statusPayload: Swift.String
  public let statusUpdated: Foundation.Date?
  public let updated: Foundation.Date?
  public let fields: [Swift.String : Swift.String]
  public let supplementalInformationFields: [TinkCore.Provider.FieldSpecification]
  public struct ThirdPartyAppAuthentication {
    public let downloadTitle: Swift.String?
    public let downloadMessage: Swift.String?
    public let upgradeTitle: Swift.String?
    public let upgradeMessage: Swift.String?
    public let appStoreURL: Foundation.URL?
    public let scheme: Swift.String?
    public let deepLinkURL: Foundation.URL?
    public var hasAutoStartToken: Swift.Bool {
      get
    }
    public init(downloadTitle: Swift.String?, downloadMessage: Swift.String?, upgradeTitle: Swift.String?, upgradeMessage: Swift.String?, appStoreURL: Foundation.URL?, scheme: Swift.String?, deepLinkURL: Foundation.URL?)
  }
  public let thirdPartyAppAuthentication: TinkCore.Credentials.ThirdPartyAppAuthentication?
  public let sessionExpiryDate: Foundation.Date?
  public init(id: TinkCore.Credentials.ID, providerID: TinkCore.Provider.ID, kind: TinkCore.Credentials.Kind, status: TinkCore.Credentials.Status, statusPayload: Swift.String, statusUpdated: Foundation.Date?, updated: Foundation.Date?, fields: [Swift.String : Swift.String], supplementalInformationFields: [TinkCore.Provider.FieldSpecification], thirdPartyAppAuthentication: TinkCore.Credentials.ThirdPartyAppAuthentication?, sessionExpiryDate: Foundation.Date?)
}
public protocol CredentialsService {
  func credentialsList(completion: @escaping (Swift.Result<[TinkCore.Credentials], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func credentials(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func create(providerID: TinkCore.Provider.ID, refreshableItems: TinkCore.RefreshableItems, fields: [Swift.String : Swift.String], appURI: Foundation.URL?, callbackURI: Foundation.URL?, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func delete(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func update(id: TinkCore.Credentials.ID, providerID: TinkCore.Provider.ID, appURI: Foundation.URL?, callbackURI: Foundation.URL?, fields: [Swift.String : Swift.String], completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func refresh(id: TinkCore.Credentials.ID, authenticate: Swift.Bool, refreshableItems: TinkCore.RefreshableItems, optIn: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func addSupplementalInformation(id: TinkCore.Credentials.ID, fields: [Swift.String : Swift.String], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func cancelSupplementalInformation(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func enable(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func disable(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func thirdPartyCallback(state: Swift.String, parameters: [Swift.String : Swift.String], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func authenticate(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func qrCode(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct CurrencyCode : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public let value: Swift.String
  public init(_ value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.CurrencyCode, b: TinkCore.CurrencyCode) -> Swift.Bool
}
public struct CurrencyDenominatedAmount : Swift.Equatable, Swift.Hashable {
  public let value: Foundation.Decimal
  public let currencyCode: TinkCore.CurrencyCode
  public static func == (a: TinkCore.CurrencyDenominatedAmount, b: TinkCore.CurrencyDenominatedAmount) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension CurrencyDenominatedAmount {
  public var doubleValue: Swift.Double {
    get
  }
  public init()
  public init(_ int: Swift.Int, currencyCode: TinkCore.CurrencyCode)
  public init(_ double: Swift.Double, currencyCode: TinkCore.CurrencyCode)
  public init(_ decimal: Foundation.Decimal, currencyCode: TinkCore.CurrencyCode)
  public init(_ number: Foundation.NSNumber, currencyCode: TinkCore.CurrencyCode)
}
extension CurrencyDenominatedAmount {
  public static func + (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
  public static func - (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
  public static func * (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
  public static func / (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
}
public enum Environment {
  case production
  case custom(restURL: Foundation.URL)
}
extension Provider {
  public struct FinancialInstitution : Swift.Hashable {
    public typealias ID = TinkCore.Identifier<TinkCore.Provider.FinancialInstitution>
    public let id: TinkCore.Provider.FinancialInstitution.ID
    public let name: Swift.String
    public init(id: TinkCore.Provider.FinancialInstitution.ID, name: Swift.String)
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TinkCore.Provider.FinancialInstitution, b: TinkCore.Provider.FinancialInstitution) -> Swift.Bool
  }
}
public enum HTTPStatusCodeError : Swift.Error {
  case badRequest
  case unauthorized
  case forbidden
  case notFound
  case conflict
  case preconditionFailed
  case unavailableForLegalReasons
  case internalServerError
  case serverError(Swift.Int)
  case clientError(Swift.Int)
}
public struct Identifier<Type> : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public let value: Swift.String
  public init(_ value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public static func == (a: TinkCore.Identifier<Type>, b: TinkCore.Identifier<Type>) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Tink {
  public static var availableLocales: [Foundation.Locale] {
    get
  }
  public static var defaultLocale: Foundation.Locale {
    get
  }
}
public struct Market : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(code value: Swift.String)
  public var code: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Market : Swift.Comparable {
  public static func < (lhs: TinkCore.Market, rhs: TinkCore.Market) -> Swift.Bool
}
public protocol OAuthService {
  func createAnonymous(market: TinkCore.Market?, locale: Foundation.Locale, origin: Swift.String?, completion: @escaping (Swift.Result<TinkCore.AccessToken, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func authenticate(clientID: Swift.String, code: TinkCore.AuthorizationCode, completion: @escaping (Swift.Result<TinkCore.AccessToken, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct Period {
  public enum Resolution {
    case monthly
    case monthlyAdjusted
    public static func == (a: TinkCore.Period.Resolution, b: TinkCore.Period.Resolution) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let dateInterval: Foundation.DateInterval
  public let name: Swift.String
  public let resolution: TinkCore.Period.Resolution
  public init(dateInterval: Foundation.DateInterval, name: Swift.String, resolution: TinkCore.Period.Resolution)
}
extension Period.Resolution {
  public var statisticResolution: TinkCore.Statistic.Resolution {
    get
  }
}
public struct Provider : Swift.Identifiable {
  public typealias ID = TinkCore.Identifier<TinkCore.Provider>
  public let id: TinkCore.Provider.ID
  public let displayName: Swift.String
  public enum AuthenticationUserType {
    case unknown
    case business
    case personal
    case corporate
    public static func == (a: TinkCore.Provider.AuthenticationUserType, b: TinkCore.Provider.AuthenticationUserType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let authenticationUserType: TinkCore.Provider.AuthenticationUserType
  public enum Kind {
    case unknown
    case bank
    case creditCard
    case broker
    case other
    case test
    case fraud
    case businessBank
    case firstParty
    public static var `default`: Swift.Set<TinkCore.Provider.Kind>
    @available(*, deprecated, renamed: "default")
    public static var defaultKinds: Swift.Set<TinkCore.Provider.Kind>
    public static var onlyTest: Swift.Set<TinkCore.Provider.Kind>
    @available(*, deprecated)
    public static var excludingTest: Swift.Set<TinkCore.Provider.Kind>
    public static var all: Swift.Set<TinkCore.Provider.Kind>
    public static func == (a: TinkCore.Provider.Kind, b: TinkCore.Provider.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let kind: TinkCore.Provider.Kind
  public enum Status {
    case unknown
    case enabled
    case disabled
    case temporaryDisabled
    case obsolete
    public static func == (a: TinkCore.Provider.Status, b: TinkCore.Provider.Status) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let status: TinkCore.Provider.Status
  public let credentialsKind: TinkCore.Credentials.Kind
  public let helpText: Swift.String?
  public let isPopular: Swift.Bool
  public struct FieldSpecification {
    public let fieldDescription: Swift.String
    public let hint: Swift.String
    public let maxLength: Swift.Int?
    public let minLength: Swift.Int?
    public let isMasked: Swift.Bool
    public let isNumeric: Swift.Bool
    public let isImmutable: Swift.Bool
    public let isOptional: Swift.Bool
    public let name: Swift.String
    public let initialValue: Swift.String
    public let pattern: Swift.String
    public let patternError: Swift.String
    public let helpText: Swift.String
    public init(fieldDescription: Swift.String, hint: Swift.String, maxLength: Swift.Int?, minLength: Swift.Int?, isMasked: Swift.Bool, isNumeric: Swift.Bool, isImmutable: Swift.Bool, isOptional: Swift.Bool, name: Swift.String, initialValue: Swift.String, pattern: Swift.String, patternError: Swift.String, helpText: Swift.String)
    public mutating func setImmutable(initialValue newValue: Swift.String)
  }
  public let fields: [TinkCore.Provider.FieldSpecification]
  public let groupDisplayName: Swift.String
  public let image: Foundation.URL?
  public let displayDescription: Swift.String
  public struct Capabilities : Swift.OptionSet, Swift.Hashable {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let transfers: TinkCore.Provider.Capabilities
    public static let mortgageAggregation: TinkCore.Provider.Capabilities
    public static let checkingAccounts: TinkCore.Provider.Capabilities
    public static let savingsAccounts: TinkCore.Provider.Capabilities
    public static let creditCards: TinkCore.Provider.Capabilities
    public static let investments: TinkCore.Provider.Capabilities
    public static let loans: TinkCore.Provider.Capabilities
    public static let payments: TinkCore.Provider.Capabilities
    public static let mortgageLoan: TinkCore.Provider.Capabilities
    public static let identityData: TinkCore.Provider.Capabilities
    public static let eInvoices: TinkCore.Provider.Capabilities
    public static let listBeneficiaries: TinkCore.Provider.Capabilities
    public static let createBeneficiaries: TinkCore.Provider.Capabilities
    public static let all: TinkCore.Provider.Capabilities
    public typealias Element = TinkCore.Provider.Capabilities
    public typealias ArrayLiteralElement = TinkCore.Provider.Capabilities
    public typealias RawValue = Swift.Int
  }
  public let capabilities: TinkCore.Provider.Capabilities
  public enum AccessType : Swift.Hashable {
    case unknown
    case openBanking
    case other
    public static let all: Swift.Set<TinkCore.Provider.AccessType>
    public static func == (a: TinkCore.Provider.AccessType, b: TinkCore.Provider.AccessType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let accessType: TinkCore.Provider.AccessType
  public let marketCode: Swift.String
  public let financialInstitution: TinkCore.Provider.FinancialInstitution
  public init(id: TinkCore.Provider.ID, displayName: Swift.String, authenticationUserType: TinkCore.Provider.AuthenticationUserType, kind: TinkCore.Provider.Kind, status: TinkCore.Provider.Status, credentialsKind: TinkCore.Credentials.Kind, helpText: Swift.String?, isPopular: Swift.Bool, fields: [TinkCore.Provider.FieldSpecification], groupDisplayName: Swift.String, image: Foundation.URL?, displayDescription: Swift.String, capabilities: TinkCore.Provider.Capabilities, accessType: TinkCore.Provider.AccessType, marketCode: Swift.String, financialInstitution: TinkCore.Provider.FinancialInstitution)
}
extension Set where Element == TinkCore.Provider.Kind {
  public static var all: Swift.Set<TinkCore.Provider.Kind> {
    get
  }
  public static var `default`: Swift.Set<TinkCore.Provider.Kind> {
    get
  }
  @available(*, deprecated, renamed: "default")
  public static var defaultKinds: Swift.Set<TinkCore.Provider.Kind>
  public static var onlyTest: Swift.Set<TinkCore.Provider.Kind> {
    get
  }
}
extension Set where Element == TinkCore.Provider.AccessType {
  public static var all: Swift.Set<TinkCore.Provider.AccessType> {
    get
  }
}
public protocol ProviderService {
  func providers(id: TinkCore.Provider.ID?, capabilities: TinkCore.Provider.Capabilities?, includeTestProviders: Swift.Bool, excludeNonTestProviders: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.Provider], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct RefreshableItems : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let checkingAccounts: TinkCore.RefreshableItems
  public static let checkingTransactions: TinkCore.RefreshableItems
  public static let savingAccounts: TinkCore.RefreshableItems
  public static let savingTransactions: TinkCore.RefreshableItems
  public static let creditCardAccounts: TinkCore.RefreshableItems
  public static let creditCardTransactions: TinkCore.RefreshableItems
  public static let loanAccounts: TinkCore.RefreshableItems
  public static let loanTransactions: TinkCore.RefreshableItems
  public static let investmentAccounts: TinkCore.RefreshableItems
  public static let investmentTransactions: TinkCore.RefreshableItems
  public static let eInvoices: TinkCore.RefreshableItems
  public static let transferDestinations: TinkCore.RefreshableItems
  public static let identityData: TinkCore.RefreshableItems
  public static let accounts: TinkCore.RefreshableItems
  public static let transactions: TinkCore.RefreshableItems
  public static let all: TinkCore.RefreshableItems
  public typealias RawValue = Swift.Int
  public typealias Element = TinkCore.RefreshableItems
  public typealias ArrayLiteralElement = TinkCore.RefreshableItems
}
extension RefreshableItems {
  public init(providerCapabilities: TinkCore.Provider.Capabilities)
  public func supporting(providerCapabilities: TinkCore.Provider.Capabilities) -> TinkCore.RefreshableItems
}
public protocol Retriable {
  func retry()
}
public typealias RetryCancellable = (TinkCore.Cancellable & TinkCore.Retriable)
public struct Scope {
}
extension Scope : Swift.Equatable {
  public static func == (a: TinkCore.Scope, b: TinkCore.Scope) -> Swift.Bool
}
extension Scope {
  public enum ReadAccess : Swift.String {
    case read
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ReadWriteAccess : Swift.String {
    case read, write
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum AuthorizationAccess : Swift.String {
    case grant, read, revoke
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum CredentialsAccess : Swift.String {
    case read, write, refresh
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TransactionAccess : Swift.String {
    case read, write, categorize
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TransferAccess : Swift.String {
    case read, execute
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum UserAccess : Swift.String {
    case create, delete, read, webHooks, write
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public static func accounts(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func activities(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func authorization(_ access: TinkCore.Scope.AuthorizationAccess...) -> TinkCore.Scope
  public static func beneficiaries(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func budgets(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func calendar(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func categories(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func contacts(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func credentials(_ access: TinkCore.Scope.CredentialsAccess...) -> TinkCore.Scope
  public static func dataExports(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func documents(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func follow(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func identity(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func insights(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func investments(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func properties(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func providers(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func statistics(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func suggestions(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func transactions(_ access: TinkCore.Scope.TransactionAccess...) -> TinkCore.Scope
  public static func transfer(_ access: TinkCore.Scope.TransferAccess...) -> TinkCore.Scope
  public static func user(_ access: TinkCore.Scope.UserAccess...) -> TinkCore.Scope
}
public struct ScopeDescription {
  public let title: Swift.String
  public let description: Swift.String
}
@_hasMissingDesignatedInitializers final public class ServiceContainer {
  final public var authenticationService: TinkCore.AuthenticationService {
    get
  }
  final public var oAuthService: TinkCore.OAuthService {
    get
  }
  final public var beneficiaryService: TinkCore.BeneficiaryService {
    get
  }
  final public var credentialsService: TinkCore.CredentialsService {
    get
  }
  final public var providerService: TinkCore.ProviderService {
    get
  }
  final public var transferService: TinkCore.TransferService {
    get
  }
  final public var userService: TinkCore.UserService {
    get
  }
  final public var accountService: TinkCore.AccountService {
    get
  }
  final public var actionableInsightService: TinkCore.ActionableInsightService {
    get
  }
  final public var budgetService: TinkCore.BudgetService {
    get
  }
  final public var calendarService: TinkCore.CalendarService {
    get
  }
  final public var categoryService: TinkCore.CategoryService {
    get
  }
  final public var statisticService: TinkCore.StatisticService {
    get
  }
  final public var transactionService: TinkCore.TransactionService {
    get
  }
  @objc deinit
}
public enum ServiceError : Swift.Error {
  case cancelled
  case invalidArgument(Swift.String)
  case notFound(Swift.String)
  case alreadyExists(Swift.String)
  case permissionDenied(Swift.String)
  case unauthenticated(Swift.String)
  case failedPrecondition(Swift.String)
  case unavailableForLegalReasons(Swift.String)
  case internalError(Swift.String)
}
public protocol SessionManager {
}
public struct SessionUser {
  public var username: Swift.String? {
    get
  }
}
public struct SignableOperation {
  public typealias ID = TinkCore.Identifier<TinkCore.SignableOperation>
  public enum Status {
    case awaitingCredentials
    case awaitingThirdPartyAppAuthentication
    case created
    case executing
    case executed
    case failed
    case cancelled
    case unknown
    public static func == (a: TinkCore.SignableOperation.Status, b: TinkCore.SignableOperation.Status) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Kind {
    case transfer
    public static func == (a: TinkCore.SignableOperation.Kind, b: TinkCore.SignableOperation.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let created: Foundation.Date?
  public let credentialsID: TinkCore.Credentials.ID?
  public let id: TinkCore.SignableOperation.ID?
  public let status: TinkCore.SignableOperation.Status
  public let statusMessage: Swift.String?
  public let kind: TinkCore.SignableOperation.Kind
  public let transferID: TinkCore.Transfer.ID?
  public let updated: Foundation.Date?
  public init(created: Foundation.Date?, credentialsID: TinkCore.Credentials.ID?, id: TinkCore.SignableOperation.ID?, status: TinkCore.SignableOperation.Status, statusMessage: Swift.String?, kind: TinkCore.SignableOperation.Kind, transferID: TinkCore.Transfer.ID?, updated: Foundation.Date?, userID: TinkCore.User.ID?)
}
public struct Statistic {
  public enum Resolution {
    case daily, monthly, monthlyAdjusted, yearly, all, weekly
    public static func == (a: TinkCore.Statistic.Resolution, b: TinkCore.Statistic.Resolution) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Kind {
    case balancesByAccount
    case balancesByAccountTypeGroup
    case expensesByCategory
    case expensesByPrimaryCategory
    case expensesByCategoryByCount
    case expensesByPrimaryCategoryByCount
    case incomeByCategory
    case incomeAndExpenses
    case leftToSpend
    case leftToSpendAverage
    public static func == (a: TinkCore.Statistic.Kind, b: TinkCore.Statistic.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let description: Swift.String
  public let payload: Swift.String?
  public let period: TinkCore.StatisticPeriod
  public let resoultion: TinkCore.Statistic.Resolution
  public let kind: TinkCore.Statistic.Kind
  public let value: Swift.Double
  public let userID: Swift.String
  public init(description: Swift.String, payload: Swift.String?, period: TinkCore.StatisticPeriod, resoultion: TinkCore.Statistic.Resolution, kind: TinkCore.Statistic.Kind, value: Swift.Double, userID: Swift.String)
}
public enum StatisticPeriod : Swift.Hashable {
  case year(Swift.Int)
  case week(year: Swift.Int, week: Swift.Int)
  case month(year: Swift.Int, month: Swift.Int)
  case day(year: Swift.Int, month: Swift.Int, day: Swift.Int)
  public var stringRepresentation: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.StatisticPeriod, b: TinkCore.StatisticPeriod) -> Swift.Bool
}
public protocol StatisticService {
  func statistics(description: Swift.String?, periods: [TinkCore.StatisticPeriod], types: [TinkCore.Statistic.Kind], resolution: TinkCore.Statistic.Resolution, padResultsUntilToday: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.Statistic], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
extension Tink {
  @discardableResult
  public func _createTemporaryUser(for market: TinkCore.Market, locale: Foundation.Locale = Tink.defaultLocale, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  public var _sdkName: Swift.String {
    get
    set
  }
}
public class Tink {
  public static var shared: TinkCore.Tink {
    get
  }
  public var sessionManagers: [TinkCore.SessionManager]
  public var userSession: TinkCore.UserSession? {
    get
    set
  }
  public init(configuration: TinkCore.Tink.Configuration)
  public static func configure(with configuration: TinkCore.Tink.Configuration)
  final public let configuration: TinkCore.Tink.Configuration
  public var services: TinkCore.ServiceContainer {
    get
  }
  @objc deinit
}
extension Tink {
  public enum UserError : Swift.Error {
    case invalidMarketOrLocale(Swift.String)
  }
  @discardableResult
  public func authenticateUser(authorizationCode: TinkCore.AuthorizationCode, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
extension Tink {
  @available(*, deprecated, message: "Set the userSession property directly instead.")
  public func setCredential(_ credential: TinkCore.SessionCredential?)
}
public struct Transaction {
  public typealias ID = TinkCore.Identifier<TinkCore.Transaction>
  public let accountID: TinkCore.Account.ID
  public let amount: TinkCore.CurrencyDenominatedAmount?
  public var categoryID: TinkCore.Category.ID
  public let description: Swift.String
  public let date: Foundation.Date?
  public let id: TinkCore.Transaction.ID
  public let inserted: Foundation.Date?
  public let isUpcomingOrInFuture: Swift.Bool
  public init(id: TinkCore.Transaction.ID, accountID: TinkCore.Account.ID, amount: TinkCore.CurrencyDenominatedAmount?, categoryID: TinkCore.Category.ID, description: Swift.String, date: Foundation.Date?, inserted: Foundation.Date?, isUpcomingOrInFuture: Swift.Bool)
}
extension Transaction : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.Transaction, b: TinkCore.Transaction) -> Swift.Bool
}
public struct TransactionsQuery : Swift.Equatable {
  public var accountIDs: [TinkCore.Account.ID]
  public var categoryIDs: [TinkCore.Category.ID]
  public var dateInterval: Foundation.DateInterval?
  public var query: Swift.String?
  public var includeUpcoming: Swift.Bool
  public var sort: TinkCore.TransactionsQuery.Sort
  public var order: TinkCore.TransactionsQuery.Order
  public var limit: Swift.Int?
  public enum Sort : Swift.String {
    case date
    case account
    case description
    case amount
    case category
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Order : Swift.String {
    case ascending
    case descending
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public init(accountIDs: [TinkCore.Account.ID] = [], categoryIDs: [TinkCore.Category.ID] = [], dateInterval: Foundation.DateInterval? = nil, query: Swift.String? = nil, includeUpcoming: Swift.Bool = false, sort: TinkCore.TransactionsQuery.Sort = .date, order: TinkCore.TransactionsQuery.Order = .descending, limit: Swift.Int? = nil)
  public static func == (a: TinkCore.TransactionsQuery, b: TinkCore.TransactionsQuery) -> Swift.Bool
}
public enum TransactionsQueryError : Swift.Error {
  case notMatchable
  public static func == (a: TinkCore.TransactionsQueryError, b: TinkCore.TransactionsQueryError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Collection where Self.Element == TinkCore.Transaction {
  public func filter(with query: TinkCore.TransactionsQuery) throws -> [TinkCore.Transaction]
}
public protocol TransactionService {
  func transactions(query: TinkCore.TransactionsQuery, offset: Swift.Int?, completion: @escaping (Swift.Result<([TinkCore.Transaction], Swift.Bool), Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func categorize(_ transactionIDs: [Swift.String], as newCategoryID: Swift.String, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func transactionsSimilar(to transactionID: Swift.String, ifCategorizedAs categoryID: Swift.String, completion: @escaping (Swift.Result<[TinkCore.Transaction], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct Transfer {
  public typealias ID = TinkCore.Identifier<TinkCore.Transfer>
}
public protocol TransferService {
  func accounts(destinationURIs: [Foundation.URL], completion: @escaping (Swift.Result<[TinkCore.Account], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func transfer(amount: Foundation.Decimal, currency: TinkCore.CurrencyCode, credentialsID: TinkCore.Credentials.ID?, transferID: TinkCore.Transfer.ID?, sourceURI: Swift.String, destinationURI: Swift.String, sourceMessage: Swift.String?, destinationMessage: Swift.String, dueDate: Foundation.Date?, redirectURI: Foundation.URL, completion: @escaping (Swift.Result<TinkCore.SignableOperation, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func transferStatus(id: TinkCore.Transfer.ID, completion: @escaping (Swift.Result<TinkCore.SignableOperation, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct User {
  public typealias ID = TinkCore.Identifier<TinkCore.User>
  public let created: Foundation.Date
  public let id: TinkCore.User.ID
  public let username: Swift.String?
  public let profile: TinkCore.UserProfile
  public init(created: Foundation.Date, id: TinkCore.User.ID, username: Swift.String?, nationalID: Swift.String?, profile: TinkCore.UserProfile)
}
public struct UserProfile {
  public let currency: TinkCore.CurrencyCode
  public let locale: Foundation.Locale
  public let market: TinkCore.Market
  public let periodAdjustedDay: Swift.Int
  public let periodMode: TinkCore.Period.Resolution
  public let timeZone: Foundation.TimeZone?
  public init(currency: TinkCore.CurrencyCode, locale: Foundation.Locale, market: TinkCore.Market, periodAdjustedDay: Swift.Int, periodMode: TinkCore.Period.Resolution, timeZone: Foundation.TimeZone?)
}
public protocol UserService {
  func userProfile(completion: @escaping (Swift.Result<TinkCore.UserProfile, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func user(completion: @escaping (Swift.Result<TinkCore.User, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
@available(*, deprecated, renamed: "UserSession")
public typealias SessionCredential = TinkCore.UserSession
public enum UserSession {
  case sessionID(Swift.String)
  case accessToken(Swift.String)
}
extension TinkCore.Account.Kind : Swift.Equatable {}
extension TinkCore.Account.Kind : Swift.Hashable {}
extension TinkCore.ActionableInsight.BudgetPeriodUnit : Swift.Equatable {}
extension TinkCore.ActionableInsight.BudgetPeriodUnit : Swift.Hashable {}
extension TinkCore.Budget.RecurringPeriodicity.PeriodUnit : Swift.Equatable {}
extension TinkCore.Budget.RecurringPeriodicity.PeriodUnit : Swift.Hashable {}
extension TinkCore.Category.Kind : Swift.RawRepresentable {}
extension TinkCore.Credentials.Kind : Swift.Equatable {}
extension TinkCore.Credentials.Kind : Swift.Hashable {}
extension TinkCore.Credentials.Status : Swift.Equatable {}
extension TinkCore.Credentials.Status : Swift.Hashable {}
extension TinkCore.Period.Resolution : Swift.Equatable {}
extension TinkCore.Period.Resolution : Swift.Hashable {}
extension TinkCore.Provider.AuthenticationUserType : Swift.Equatable {}
extension TinkCore.Provider.AuthenticationUserType : Swift.Hashable {}
extension TinkCore.Provider.Kind : Swift.Equatable {}
extension TinkCore.Provider.Kind : Swift.Hashable {}
extension TinkCore.Provider.Status : Swift.Equatable {}
extension TinkCore.Provider.Status : Swift.Hashable {}
extension TinkCore.Scope.ReadAccess : Swift.Equatable {}
extension TinkCore.Scope.ReadAccess : Swift.Hashable {}
extension TinkCore.Scope.ReadAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.ReadWriteAccess : Swift.Equatable {}
extension TinkCore.Scope.ReadWriteAccess : Swift.Hashable {}
extension TinkCore.Scope.ReadWriteAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.AuthorizationAccess : Swift.Equatable {}
extension TinkCore.Scope.AuthorizationAccess : Swift.Hashable {}
extension TinkCore.Scope.AuthorizationAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.CredentialsAccess : Swift.Equatable {}
extension TinkCore.Scope.CredentialsAccess : Swift.Hashable {}
extension TinkCore.Scope.CredentialsAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.TransactionAccess : Swift.Equatable {}
extension TinkCore.Scope.TransactionAccess : Swift.Hashable {}
extension TinkCore.Scope.TransactionAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.TransferAccess : Swift.Equatable {}
extension TinkCore.Scope.TransferAccess : Swift.Hashable {}
extension TinkCore.Scope.TransferAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.UserAccess : Swift.Equatable {}
extension TinkCore.Scope.UserAccess : Swift.Hashable {}
extension TinkCore.Scope.UserAccess : Swift.RawRepresentable {}
extension TinkCore.SignableOperation.Status : Swift.Equatable {}
extension TinkCore.SignableOperation.Status : Swift.Hashable {}
extension TinkCore.SignableOperation.Kind : Swift.Equatable {}
extension TinkCore.SignableOperation.Kind : Swift.Hashable {}
extension TinkCore.Statistic.Kind : Swift.Equatable {}
extension TinkCore.Statistic.Kind : Swift.Hashable {}
extension TinkCore.Statistic.Resolution : Swift.Equatable {}
extension TinkCore.Statistic.Resolution : Swift.Hashable {}
extension TinkCore.TransactionsQuery.Sort : Swift.Equatable {}
extension TinkCore.TransactionsQuery.Sort : Swift.Hashable {}
extension TinkCore.TransactionsQuery.Sort : Swift.RawRepresentable {}
extension TinkCore.TransactionsQuery.Order : Swift.Equatable {}
extension TinkCore.TransactionsQuery.Order : Swift.Hashable {}
extension TinkCore.TransactionsQuery.Order : Swift.RawRepresentable {}
extension TinkCore.TransactionsQueryError : Swift.Equatable {}
extension TinkCore.TransactionsQueryError : Swift.Hashable {}
